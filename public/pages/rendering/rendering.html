
<h1>Rendering</h1>

<h2>When an HTML page is sent it needs its dynamic portions rendered.</h2>

<p>
    HTML pages have many components that are created by means of javascript. 
    When in the process this generation occurs defines whether it is server side or client side.
</p>
<p>
    If the server just delivers an HTML file with scripts referenced within, it is a client side rendering.
    The client browser receives the file and renders it locally. This means that each version of the page is unique of sorts.
    The contents might be the same as elsewhere, by they have been interpreted my each individual browser.
    This is an example of how a root request might look on a client side rendering.
</p>
<pre>
    <code>
        app.get("/", (req, res) => {
            res.sendFile(__dirname + "/public/frontpage/frontpage.html")
        });
        
    </code>
</pre>
<p>Here the entire HTML page is sent, with its correct directory being generated by the "__dirname" + relative path.</p>
<p>
    If the server delivers a string, where all the generation has already occured, it is rendered server side. 
    This has the added benefit of allowing for SEO (Search Engine Optimization) as Google's spiders can read the page and rank it accordingly.
    The following is an example of how a similiar root request might look when generated server side.
</p>
<pre>
    <code>
        const frontpage = templateEngine.readPage('./public/pages/frontpage/frontpage.html');
        const frontpagePage = templateEngine.renderPage(frontpage, {
          tabTitle: 'nJd | welcome'
        });
        
        app.get('/', ((req, res) => {
          res.send(frontpagePage);
        }));
    </code>
</pre>
<p>
    In order to completely understand what is happening, we need to break it down. 
    In this example we have an entirely new module called templateEngine.
    The body of templateEngine looks like this:
</p>
<pre>
    <code>
        import fs from 'fs';

        function readPage(pagePath) {
        return fs.readFileSync(pagePath.toString());
        }
  
        function renderPage(page, config = {}) {
        const navbar = fs.readFileSync('./public/components/navbar/navbar.html')
            .toString()
            .replace('$TAB_TITLE', config.tabTitle || 'Node JS doc')
            .replace('$LOGIN', config.access || 'login');

        const footer = fs.readFileSync('./public/components/footer/footer.html')
            .toString()
            .replace('$FOOTER_YEAR', `Â© Etienne Olieu - ${new Date().getFullYear()}`);

        return navbar + page + footer;
        }

        export default {
            renderPage,
            readPage,
        };
    </code>
</pre>
<p>
    A lot is happening here.
    Essentially, the templateEngine takes a filepath and translates it in full into a string. 
    The next step is to create a sandwich of the header with a navbar and a footer.
    These are also handled as strings and merely concatenated on either end of the HTML-file-to-string.
</p>
<h3 id="poem">Server-side magic,<br>
    HTML flows like a river,<br>
    Fast and SEO-friendly.</h3>